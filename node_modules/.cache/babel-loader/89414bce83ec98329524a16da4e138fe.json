{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\burni\\\\Desktop\\\\React - Web Dev\\\\01-starting-setup\\\\src\\\\components\\\\Expenses\\\\ExpensesList.js\";\nimport React from \"react\";\nimport ExpenseItem from \"./ExpenseItem\";\nimport \"./ExpensesList.css\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\n\nconst ExpensesList = props => {\n  // If we have no registered expenses for a specific year ---> display a message \n  let expenseContent = /*#__PURE__*/_jsxDEV(\"p\", {\n    children: \"No Expenses Found\"\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 9,\n    columnNumber: 24\n  }, this);\n\n  if (props.passedFilteredExpenses.length > 0) {\n    expenseContent = props.passedFilteredExpenses.map(expense => /*#__PURE__*/_jsxDEV(ExpenseItem, {\n      // **** always add a KEY when mapping out a list of items, inorder to avoid errors in the console. React needs to uniquely identify every element it adds inorder to be efficient and not go over the whole list of items everytime we add a new item. If we dont add a KEY, react will update ALL the items in the array and replaces their content such that they match the old content of the array, after adding the new item. WHICH IS INEFFIECIENT performance wise AND CAN CAUSE BUGS.\n      title: expense.title,\n      date: expense.date,\n      amount: expense.amount\n    }, expense.id, false, {\n      fileName: _jsxFileName,\n      lineNumber: 14,\n      columnNumber: 7\n    }, this));\n  } // This explanation is when we had the above function with \".map\" inside the retrun function (as JSX code). Not any more tho since we moved the logic outside of the return function.\n\n  /* Rendering the \"expenses\" Array (in \"App.js\") Dynamically \r\n            1. Creat curly braces \"{...}* because we will execute a dynamic javascript expression in JSX code, which is why we need the curly braces.\r\n            2. Reference the \"expenses\" array (in \"App.js\") through \"props\" and its attribute name in the \"<expenses />\" custom element. (ie: \"props.items\")\r\n            3. Use the \"map()\" javascript function to create a new array (through its paramter), based on another array (\"expenses\" array in this case,\r\n               which we acces through \"props.items\")\r\n          SO FOR EACH OBJECT IN THE \"expense\" ARRAY, \"map()\" creates a new \"ExpenseItem\" with the properties from the corresponding \"expense\" array object.  */\n\n\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    children: expenseContent\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 34,\n    columnNumber: 9\n  }, this);\n};\n\n_c = ExpensesList;\nexport default ExpensesList;\n\nvar _c;\n\n$RefreshReg$(_c, \"ExpensesList\");","map":{"version":3,"sources":["C:/Users/burni/Desktop/React - Web Dev/01-starting-setup/src/components/Expenses/ExpensesList.js"],"names":["React","ExpenseItem","ExpensesList","props","expenseContent","passedFilteredExpenses","length","map","expense","title","date","amount","id"],"mappings":";AAAA,OAAOA,KAAP,MAAkB,OAAlB;AACA,OAAOC,WAAP,MAAwB,eAAxB;AAEA,OAAO,oBAAP;;;AAEA,MAAMC,YAAY,GAAIC,KAAD,IAAW;AAE5B;AACF,MAAIC,cAAc,gBAAG;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,UAArB;;AAEA,MAAID,KAAK,CAACE,sBAAN,CAA6BC,MAA7B,GAAsC,CAA1C,EAA6C;AAE3CF,IAAAA,cAAc,GAAGD,KAAK,CAACE,sBAAN,CAA6BE,GAA7B,CAAkCC,OAAD,iBAChD,QAAC,WAAD;AACqB;AACnB,MAAA,KAAK,EAAEA,OAAO,CAACC,KAFjB;AAGE,MAAA,IAAI,EAAED,OAAO,CAACE,IAHhB;AAIE,MAAA,MAAM,EAAEF,OAAO,CAACG;AAJlB,OACOH,OAAO,CAACI,EADf;AAAA;AAAA;AAAA;AAAA,YADe,CAAjB;AASD,GAhB6B,CAkB9B;;AACA;AACF;AACA;AACA;AACA;AACA;;;AAGI,sBACI;AAAA,cACKR;AADL;AAAA;AAAA;AAAA;AAAA,UADJ;AAKH,CAhCD;;KAAMF,Y;AAmCN,eAAeA,YAAf","sourcesContent":["import React from \"react\";\r\nimport ExpenseItem from \"./ExpenseItem\";\r\n\r\nimport \"./ExpensesList.css\"\r\n\r\nconst ExpensesList = (props) => {\r\n\r\n    // If we have no registered expenses for a specific year ---> display a message \r\n  let expenseContent = <p>No Expenses Found</p>;\r\n\r\n  if (props.passedFilteredExpenses.length > 0) {\r\n\r\n    expenseContent = props.passedFilteredExpenses.map((expense) => (\r\n      <ExpenseItem\r\n        key={expense.id}   // **** always add a KEY when mapping out a list of items, inorder to avoid errors in the console. React needs to uniquely identify every element it adds inorder to be efficient and not go over the whole list of items everytime we add a new item. If we dont add a KEY, react will update ALL the items in the array and replaces their content such that they match the old content of the array, after adding the new item. WHICH IS INEFFIECIENT performance wise AND CAN CAUSE BUGS.\r\n        title={expense.title}\r\n        date={expense.date}\r\n        amount={expense.amount}\r\n      />\r\n    ))\r\n\r\n  }\r\n\r\n  // This explanation is when we had the above function with \".map\" inside the retrun function (as JSX code). Not any more tho since we moved the logic outside of the return function.\r\n  /* Rendering the \"expenses\" Array (in \"App.js\") Dynamically \r\n            1. Creat curly braces \"{...}* because we will execute a dynamic javascript expression in JSX code, which is why we need the curly braces.\r\n            2. Reference the \"expenses\" array (in \"App.js\") through \"props\" and its attribute name in the \"<expenses />\" custom element. (ie: \"props.items\")\r\n            3. Use the \"map()\" javascript function to create a new array (through its paramter), based on another array (\"expenses\" array in this case,\r\n               which we acces through \"props.items\")\r\n          SO FOR EACH OBJECT IN THE \"expense\" ARRAY, \"map()\" creates a new \"ExpenseItem\" with the properties from the corresponding \"expense\" array object.  */\r\n\r\n\r\n    return (\r\n        <div>\r\n            {expenseContent}\r\n        </div>\r\n    )\r\n};\r\n\r\n\r\nexport default ExpensesList;"]},"metadata":{},"sourceType":"module"}